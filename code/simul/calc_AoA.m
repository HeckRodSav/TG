function return_struct = calc_AoA( ...
	amp_w, ...
	ang_w, ...
	r_w, ...
	phase_w, ...
	lambda_w, ...
	omega_w, ...
	S, ...
	C, ...
	NOISE, ...
	SNR_dB, ...
	ATT, ...
	resolution, ...
	d, ...
	N_antenas ...
)

	% Raio do circulo de circunscreve o poligono com N lados de tamanho d
	Rho = d/(2*sin(pi / N_antenas));
	ant_angles_shift = -90;
	ant_angles = (0 + ant_angles_shift):(360/N_antenas):(359 + ant_angles_shift);

	% Coordenadas das antenas
	ant_array = Rho * exp(i * deg2rad(ant_angles));

	t = linspace(0,(2 * pi / omega_w), resolution); % Intervalo de integração

	% Calculos de fase
	Z_phase_array = arrayfun(@(a) phase_z(t, a, amp_w, ...
		ang_w, r_w, phase_w, lambda_w, omega_w, S, C, NOISE, ...
		SNR_dB, ATT), ant_array);

	% Calculos de simetria
	[Z_x_array angle_Z_A_x_B_array] = arrayfun(@(a, b) dephase_A_to_B(a, b), ...
		Z_phase_array, circshift(Z_phase_array,-1));

	[delta_A_x_B delta_B_x_A] = arrayfun(@(ang, a, b) deltas_A_B(ang, a, b), ...
		angle_Z_A_x_B_array, ant_array, circshift(ant_array,-1));

	% Fazer "votacao" de angulo escolhido
	range_angle = pi/(2*(N_antenas+1));

	angle_vector = [delta_A_x_B delta_B_x_A];
	angle_vector = [...
		(angle_vector(angle_vector<0)+(2*pi)) ...
		(angle_vector(0<=angle_vector & angle_vector<=(2*pi))) ...
		(angle_vector((2*pi)<angle_vector)-(2*pi)) ...
	]; % Normalizar vetor de angulos entre 0 e 2 pi

	angle_vector_round = round(angle_vector./range_angle).*range_angle;
	target_angle = mode(angle_vector_round);

	angle_vector = angle_vector(abs(target_angle - angle_vector) <= range_angle ); % Descartar improvavei

	choose_angle = median(angle_vector); % Calcular angulo provavel

	return_struct = { ...
		choose_angle ...
		Rho ...
		ant_array ...
		Z_phase_array ...
		Z_x_array ...
		delta_A_x_B ...
		delta_B_x_A ...
	};

end %function