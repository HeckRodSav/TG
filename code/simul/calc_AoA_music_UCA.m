function return_struct = calc_AoA_music_UCA ( ...
	amp_w, ...
	ang_w, ...
	r_w, ...
	phase_w, ...
	lambda_w, ...
	omega_w, ...
	S, ...
	C, ...
	NOISE, ...
	SNR_dB, ...
	ATT, ...
	resolution, ...
	d, ...
	N_antenas ...
)

	choose_angle = nan;
	D_signals = 1;	% Quantidade de sinais incidentes
	N_samples = 10;	% Quantidade de amostras de sinal

	% Raio do circulo de circunscreve o poligono com N_samples lados de tamanho d
	Rho = d/(2*sin(pi / N_antenas));
	ant_angles_shift = -90;
	ant_angles = deg2rad((0 + ant_angles_shift):(360/N_antenas):(359 + ant_angles_shift))';

	% Coordenadas das antenas
	ant_array = Rho * exp(i * ant_angles);

	t = linspace(0,(2 * pi / omega_w), resolution); % Intervalo de integração

	Z_phase_matrix = [];

	for i = 1:N_samples
		% Calculos de fase
		Z_phase_array = arrayfun(@(ant) phase_z(t, ant, amp_w, ...
			ang_w, r_w, phase_w, lambda_w, omega_w, S, C, NOISE, ...
			SNR_dB, ATT), ant_array);

		Z_phase_matrix = [Z_phase_matrix Z_phase_array];
	end % for

	AoA_range = deg2rad(0:0.1:360);

	steering_arguments = { ...
		Rho, ...
		ant_angles, ...
		lambda_w ...
	};

	choose_angle = music_algorithm(Z_phase_matrix, D_signals, AoA_range, @ steering_circular, steering_arguments);

	return_struct = { ...
		choose_angle, ...
	};

end %function
